## 图 Graph

![[Pasted image 20231119180831.png]]

```slide-note
file: [[DS08_Ch09-Graph Definition-Topological Sort.pdf]]
page: 1, 2
```

### 邻接矩阵 Adjacency Matrix

### 邻接链表 Adjacency Lists

在每一个 List 里 order doesn't matter

有向图 List

```slide-note
file: [[DS08_Ch09-Graph Definition-Topological Sort.pdf]]
page: 6
```


#### Adjacency MultiList 邻接十字链表

![[adjacencymultilist.png]]

![[Pasted image 20231114134232.png]]

### 最短路径

#### DFS 深度优先搜索

https://zhuanlan.zhihu.com/p/24986203

```cpp
int goal_x = 9, goal_y = 9;     //目标的坐标，暂时设置为右下角
int n = 10 , m = 10;               //地图的宽高，设置为10 * 10的表格
int graph[n][m];        //地图
int used[n][m];         //用来标记地图上那些点是走过的
int px[] = {-1, 0, 1, 0};   //通过px 和 py数组来实现左下右上的移动顺序
int py[] = {0, -1, 0, 1};
int flag = 0;           //是否能达到终点的标志

void DFS(int graph[][], int used[], int x, int y)
{
    // 如果与目标坐标相同，则成功
    if (graph[x][y] == graph[goal_x][goal_y]) {     
        printf("successful");
        flag = 1;
        return ;
    }
    // 遍历四个方向
    for (int i = 0; i != 4; ++i) {    
        //如果没有走过这个格子          
        int new_x = x + px[i], new_y = y + py[i];
        if (new_x >= 0 && new_x < n && new_y >= 0 
            && new_y < m && used[new_x][new_y] == 0 && !flag) {
            
            used[new_x][new_y] = 1;     //将该格子设为走过

            DFS(graph, used, new_x, new_y);      //递归下去

            used[new_x][new_y] = 0;//状态回溯，退回来，将格子设置为未走过
        }
    }
}
```

#### BFS 广度优先搜索

```cpp
int n = 10, m = 10;                   //地图宽高
void BFS()
{
    queue que;              //用队列来保存路口
    int graph[n][m];          //地图
    int px[] = {-1, 0, 1, 0};   //移动方向的数组
    int py[] = {0, -1, 0, 1};
    que.push(起点入队);      //将起点入队
    while (!que.empty()) {    //只要队列不为空
        auto temp = que.pop();          //得到队列中的元素
        for (int i = 0; i != 4; ++i) {
            if(//可以走) {
                //标记当前格子
                //将当前状态入队列，等待下次提取
            }
        }
    } 
}
```

#### unweighted

```c
void Unweighted(Table T) {
	int CurrDist;
	Vertex V, W;
	Q = CreateQueue(MaxSize);
    Enqueue(S, Q);
    while (!IsEmpty(Q)) {
    	V = Dequeue(Q);
    	for each W adjacent to V
    		if (T[W].Dist == Infinity) {
    			T[W].Dist = T[V].Dist + 1;
    			T[W].Path = V;
    			Enqueue(W, Q);
    		}
    }
    DisposeQueue(Q)
}
```

#### Dijkstra algorithm

[Dijstra algrithm Demo in CS61B](https://docs.google.com/presentation/d/1_bw2z1ggUkquPdhl7gwdVBoTaoJmaZdpkV6MoAgxlJc/pub?start=false&loop=false&delayms=3000&slide=id.g771336078_0_1800)

Visit vertices in order of best-known distance from source. On visit, relax every edge from the visited vertex. Dijkstra’s is guaranteed to return a correct result if all edges are **non-negative**. 

伪代码：

```c
void Dijkstra(Table T) {
    Vertex V, W;
    for ( ; ; ) {
        V = smallest unknown distance vertex;
        if (V == NotAVertex) {
            break;
        }
        T[V].Known = True;
        for each W adjacent to V {
            if (T[V].Dist + Cvw < T[W].Dist) {
                Decrease(T[W].Dist to T[V].Dist + Cvw);
                T[W].Path = V;
            }
        }
    }
}
```

![[Pasted image 20231121112009.png]]

判断是否是 Dijkstra 路径：

```c
bool IsDij(int *Seq) {
    int dist[MaxN]; /**< Array to store the shortest distance from the source vertex */
    bool known[MaxN]; /**< Array to track whether a vertex is known or not */

    // Initialize the distance array and known array
    for (int i = 1; i < Nv + 1; i ++) {
        dist[i] = INF; // Initialize the distance of all vertices to infinity
        known[i] = false; // Set all vertices as unknown
    }

    dist[Seq[0]] = 0; // Set the distance of the source vertex to 0

    for (int i = 0; i < Nv; i ++) { // Calculate the distance array
        int min = INF;
        int min_index = -1;

        // Find the unknown vertex with the smallest distance
        for (int j = 1; j < Nv + 1; j ++) {
            if (known[j] == false && dist[j] < min) {
                min = dist[j];
                min_index = j;
            }
        }

        if (min == INF) { // If no vertex is found, it means the remaining vertices are unreachable
            break;
        }

        known[min_index] = true; // Mark the vertex as known

        // Update the distance array
        for (int j = 1; j < Nv + 1; j ++) {
            if (known[j] == false && G[min_index][j] != INF) {
                if (dist[j] > dist[min_index] + G[min_index][j]) {
                    dist[j] = dist[min_index] + G[min_index][j];
                }
            }
        }
    }

    for (int i = 0; i < Nv-1; i ++) { // Check the distance array
        if (dist[Seq[i]] > dist[Seq[i + 1]]) {
            return false; // If the distance of any vertex violates the shortest path condition, return false
        }
    }

    return true; // If the distances of all vertices satisfy the shortest path condition, return true
}
```

有负路径

```c
void WeightedNegative(Table T) {
    Queue Q;
    Vertex V, W;
    Q = CreateQueue(NumVertex);
    MakeEmpty(Q);
    Enqueue(S, Q); /* Enqueue the source vertex */
    while (!IsEmpty(Q)) {
        V = Dequeue(Q);
        for (each W adjacent to V) {
            if (T[V].Dist + Cvw < T[W].Dist) {
                T[W].Dist = T[V].Dist + Cvw;
                T[W].Path = V;
                if (!IsEnqueued(W, Q)) {
                    Enqueue(W, Q);
                }
            }
        }
        DispoeseQueue(Q); /* free memory */
    }
}
```

### augmenting path 增广路径

> [!Note] Total coming in (v) = Total going out(v)

```slide-note
file: [[DS10_Ch09-Network Flow-MST.pdf]]
page: 1
```
#### 1. A simple algorithm

```slide-note
file: [[DS10_Ch09-Network Flow-MST.pdf]]
page: 2
```

![[Pasted image 20231128155437.png]]

### Spanning Tree

对于无向图，连接所有图的节点，并且没有环：Connected and Acyclic

![[Pasted image 20231121103823.png]]

#### Prim's algorithm -grow a tree(very similar to Dijkstra algorithm)

#### Kruskal's Algorithm - maintain a forest

```c
void Kruskal ( Graph G )
{   T = { } ;
    while  ( T contains less than |V| - 1 edges && E is not empty ) {
        choose a least cost edge (v, w) from E ;
        delete (v, w) from E ;
        if  ( (v, w) does not create a cycle in T )     
	add (v, w) to T ;
        else     
	discard (v, w) ;
    }
    if  ( T contains fewer than |V| - 1 edges )
        Error ( “No spanning tree” ) ;
}
```

#### UniqueMST check，在 Build MST 时判断

##### 实现思路：

1. 定义一个结构体 `Edge`，用于表示图的边，包括边的起点 `v1`、终点 `v2`、权重 `weight`，以及一个布尔值 `IsTreeEdge`，表示该边是否 **可以在最小生成树** 中。
2. `ReadGraph` 函数用于读取图的信息。首先读取顶点数 `Nv` 和边数 `Ne`，然后依次读取每条边的起点、终点和权重，并将其存储在 `edges` 数组中。最后，使用快速排序（`qsort`）对边进行按权重的 **升序排序** 。
3. `BuildMST` 函数用于构建最小生成树。首先初始化变量，将 `flag` 设置为 `true`，表示最小生成树存在。`component` 表示当前图的连通分量个数，初始化为顶点数 `Nv`。`alWeight` 表示最小生成树的总权重，初始化为 0。
4. 使用 **并查集数据结构** 来判断边是否在同一个连通分量中。首先初始化并查集，每个顶点的父节点为自身。然后进行边的遍历，根据边的权重进行分组。
5. 对于每组权重相同的边，遍历这组边，并判断边的两个顶点是否属于不同的连通分量。若属于 **不同** 的连通分量，则该边添加到最小生成树中，更新总权重 `alWeight`， **合并** 两个顶点所在的连通分量，并将 `component` 减一。如果边已经在最小生成树中，将 `flag` 设置为 `false`。  
6. 完成一组权重相同的边的处理后，继续处理下一组权重相同的边，直到所有边都被处理完。
7. 返回最小生成树的总权重 `alWeight`。
8. 在 `main` 函数中，首先调用 `ReadGraph` 读取图的信息，然后调用 `BuildMST` 构建最小生成树并获取总权重。根据情况输出结果：如果顶点数为 0，则输出 "No MST"；如果连通分量个数小于等于 1，则输出最小生成树的总权重，并根据 `flag` 输出 "Yes" 或 "No"；如果连通分量个数大于 1，则输出 "No MST" 和连通分量个数。

##### 代码实现：

```c
typedef struct {
    int v1, v2, weight;
    bool IsTreeEdge;
} Edge;

int BuildMST(void) {
    flag = true;
    component = Nv;
    int alWeight = 0;
    
    for (int i = 0; i < Nv; i++) {
        parent[i] = i;
    }
    
    for (int i = 0; i < Ne;) {
        int j = i;
        for (; j < Ne && edges[j].weight == edges[i].weight; j++) {
            if (FindParent(edges[j].v1) != FindParent(edges[j].v2)) {
                edges[j].IsTreeEdge = true;
            }
        }
        
        for (int k = i; k < j; ++k) {
            if (FindParent(edges[k].v1) != FindParent(edges[k].v2)) {
                alWeight += edges[k].weight;
                Union(edges[k].v1, edges[k].v2);
                component--;
            } else if (edges[k].IsTreeEdge == true) {
                flag = false;
            }
        }
        i = j;
    }
    
    return alWeight;
}
```

